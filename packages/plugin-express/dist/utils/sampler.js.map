{"version":3,"file":"sampler.js","sourceRoot":"","sources":["../../src/utils/sampler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Sampler Utility\n *\n * Following Sentry's sampling pattern:\n * - Global sample rate for all events\n * - Rule-based sampling for specific conditions\n * - First matching rule wins\n */\n\nimport type { SamplingConfig, SamplingRule } from '@lattice.black/core';\nimport { DEFAULT_SAMPLING_CONFIG } from '@lattice.black/core';\n\n/**\n * Context for sampling decisions\n */\nexport interface SamplingContext {\n  /** Request path */\n  path?: string;\n  /** HTTP method */\n  method?: string;\n  /** Error type name */\n  errorType?: string;\n  /** Event type (error or metric) */\n  eventType: 'error' | 'metric';\n}\n\n/**\n * Sampler class for determining whether to capture events\n */\nexport class Sampler {\n  private readonly config: SamplingConfig;\n\n  constructor(config?: Partial<SamplingConfig>) {\n    this.config = {\n      ...DEFAULT_SAMPLING_CONFIG,\n      ...config,\n      rules: config?.rules ?? [],\n    };\n  }\n\n  /**\n   * Determine if an event should be sampled (captured)\n   * Returns true if the event should be captured, false to drop it\n   */\n  shouldSample(context: SamplingContext): boolean {\n    const rate = this.getRate(context);\n\n    // Rate of 0 means never sample\n    if (rate <= 0) {\n      return false;\n    }\n\n    // Rate of 1 means always sample\n    if (rate >= 1) {\n      return true;\n    }\n\n    // Random sampling based on rate\n    return Math.random() < rate;\n  }\n\n  /**\n   * Get the sample rate for a given context\n   * Checks rules first, then falls back to global rate\n   */\n  getRate(context: SamplingContext): number {\n    // Check rules in order - first match wins\n    for (const rule of this.config.rules) {\n      if (this.matchesRule(context, rule)) {\n        return this.clampRate(rule.rate);\n      }\n    }\n\n    // Fall back to global rate based on event type\n    const globalRate =\n      context.eventType === 'error' ? this.config.errors : this.config.metrics;\n\n    return this.clampRate(globalRate);\n  }\n\n  /**\n   * Check if context matches a sampling rule\n   */\n  private matchesRule(context: SamplingContext, rule: SamplingRule): boolean {\n    const { match } = rule;\n\n    // All specified conditions must match\n    if (match.path !== undefined && !this.matchPath(context.path, match.path)) {\n      return false;\n    }\n\n    if (match.method !== undefined && context.method?.toUpperCase() !== match.method.toUpperCase()) {\n      return false;\n    }\n\n    if (match.errorType !== undefined && context.errorType !== match.errorType) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Match path with wildcard support\n   * Supports * for single segment and ** for multiple segments\n   */\n  private matchPath(actual: string | undefined, pattern: string): boolean {\n    if (!actual) {\n      return false;\n    }\n\n    // Exact match\n    if (pattern === actual) {\n      return true;\n    }\n\n    // Convert pattern to regex\n    const regexPattern = pattern\n      .replace(/\\*\\*/g, '___DOUBLE_STAR___')\n      .replace(/\\*/g, '[^/]+')\n      .replace(/___DOUBLE_STAR___/g, '.*');\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(actual);\n  }\n\n  /**\n   * Clamp rate to valid range [0, 1]\n   */\n  private clampRate(rate: number): number {\n    return Math.min(Math.max(rate, 0), 1);\n  }\n}\n\n/**\n * Create a sampler with default configuration\n */\nexport function createSampler(config?: Partial<SamplingConfig>): Sampler {\n  return new Sampler(config);\n}\n\n/**\n * Default sampler instance that samples everything\n */\nexport const defaultSampler = new Sampler();\n"]}