{"version":3,"file":"event-queue.js","sourceRoot":"","sources":["../../src/utils/event-queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Event Queue with Batching\n *\n * Following Segment's batching pattern with backpressure handling:\n * - Events are queued until batch size is reached or flush interval fires\n * - Queue has a maximum size to prevent memory exhaustion\n * - forceFlush() sends all pending events immediately\n * - shutdown() cleans up resources\n */\n\nimport { BATCH_LIMITS, SHUTDOWN_CONFIG } from '@lattice.black/core';\nimport type { BatchConfig } from '@lattice.black/core';\nimport { defaultErrorHandler, type ErrorHandler } from './safe-wrapper';\n\n/**\n * Callback for flushing events\n */\nexport type FlushCallback<T> = (events: T[]) => Promise<void>;\n\n/**\n * Event queue configuration\n */\nexport interface EventQueueConfig<T> extends BatchConfig {\n  /** Callback to flush events to the backend */\n  onFlush: FlushCallback<T>;\n  /** Error handler for failed flushes */\n  onError?: ErrorHandler;\n  /** Whether the queue is enabled */\n  enabled?: boolean;\n}\n\n/**\n * Queue state for monitoring\n */\nexport interface QueueState {\n  /** Current number of events in queue */\n  size: number;\n  /** Number of events dropped due to queue overflow */\n  dropped: number;\n  /** Number of successful flushes */\n  flushCount: number;\n  /** Number of failed flushes */\n  failedFlushCount: number;\n  /** Whether the queue is currently flushing */\n  isFlushing: boolean;\n  /** Whether the queue has been shut down */\n  isShutdown: boolean;\n}\n\n/**\n * Generic event queue with batching and backpressure\n */\nexport class EventQueue<T> {\n  private queue: T[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private isFlushing = false;\n  private isShutdown = false;\n  private droppedCount = 0;\n  private flushCount = 0;\n  private failedFlushCount = 0;\n  private readonly config: EventQueueConfig<T>;\n\n  constructor(config: EventQueueConfig<T>) {\n    // Validate and clamp configuration values\n    this.config = {\n      ...config,\n      maxBatchSize: this.clamp(\n        config.maxBatchSize,\n        BATCH_LIMITS.MIN_BATCH_SIZE,\n        BATCH_LIMITS.MAX_BATCH_SIZE\n      ),\n      flushIntervalMs: this.clamp(\n        config.flushIntervalMs,\n        BATCH_LIMITS.MIN_FLUSH_INTERVAL,\n        BATCH_LIMITS.MAX_FLUSH_INTERVAL\n      ),\n      maxQueueSize: this.clamp(\n        config.maxQueueSize,\n        BATCH_LIMITS.MIN_QUEUE_SIZE,\n        BATCH_LIMITS.MAX_QUEUE_SIZE\n      ),\n      onError: config.onError ?? defaultErrorHandler,\n      enabled: config.enabled ?? true,\n    };\n\n    // Start the flush timer if enabled\n    if (this.config.enabled) {\n      this.startTimer();\n    }\n  }\n\n  /**\n   * Add an event to the queue\n   * Returns true if event was queued, false if dropped due to backpressure\n   */\n  enqueue(event: T): boolean {\n    if (this.isShutdown || !this.config.enabled) {\n      return false;\n    }\n\n    // Check backpressure\n    if (this.queue.length >= this.config.maxQueueSize) {\n      this.droppedCount++;\n      this.config.onError?.(\n        new Error(`Queue full (${this.config.maxQueueSize}), dropping event`),\n        'EventQueue.enqueue'\n      );\n      return false;\n    }\n\n    this.queue.push(event);\n\n    // Flush immediately if batch size reached\n    if (this.queue.length >= this.config.maxBatchSize) {\n      this.flush().catch(() => {\n        // Error already handled in flush()\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Flush events up to batch size\n   * Called automatically by timer or when batch size is reached\n   */\n  async flush(): Promise<void> {\n    if (this.isShutdown || this.isFlushing || this.queue.length === 0) {\n      return;\n    }\n\n    this.isFlushing = true;\n\n    try {\n      // Take up to maxBatchSize events from the front of the queue\n      const batch = this.queue.splice(0, this.config.maxBatchSize);\n\n      if (batch.length > 0) {\n        await this.config.onFlush(batch);\n        this.flushCount++;\n      }\n    } catch (error) {\n      this.failedFlushCount++;\n      if (error instanceof Error) {\n        this.config.onError?.(error, 'EventQueue.flush');\n      }\n      // Note: We don't re-queue failed events to prevent infinite loops\n      // In production, consider a retry mechanism with backoff\n    } finally {\n      this.isFlushing = false;\n    }\n  }\n\n  /**\n   * Force flush all pending events immediately\n   * Used during shutdown or when immediate delivery is required\n   */\n  async forceFlush(timeoutMs: number = SHUTDOWN_CONFIG.DEFAULT_FLUSH_TIMEOUT): Promise<void> {\n    if (this.isShutdown) {\n      return;\n    }\n\n    // Stop the timer to prevent concurrent flushes\n    this.stopTimer();\n\n    const startTime = Date.now();\n\n    // Keep flushing until queue is empty or timeout\n    while (this.queue.length > 0 && Date.now() - startTime < timeoutMs) {\n      await this.flush();\n\n      // Small delay to prevent tight loop if flush fails\n      if (this.queue.length > 0) {\n        await this.sleep(100);\n      }\n    }\n\n    // Restart timer if not shutting down\n    if (!this.isShutdown && this.config.enabled) {\n      this.startTimer();\n    }\n  }\n\n  /**\n   * Shut down the queue\n   * Stops accepting new events and clears resources\n   */\n  shutdown(): void {\n    this.isShutdown = true;\n    this.stopTimer();\n    this.queue = [];\n  }\n\n  /**\n   * Get current queue state for monitoring\n   */\n  getState(): QueueState {\n    return {\n      size: this.queue.length,\n      dropped: this.droppedCount,\n      flushCount: this.flushCount,\n      failedFlushCount: this.failedFlushCount,\n      isFlushing: this.isFlushing,\n      isShutdown: this.isShutdown,\n    };\n  }\n\n  /**\n   * Check if the queue is empty\n   */\n  isEmpty(): boolean {\n    return this.queue.length === 0;\n  }\n\n  /**\n   * Get the number of pending events\n   */\n  size(): number {\n    return this.queue.length;\n  }\n\n  // Private methods\n\n  private startTimer(): void {\n    if (this.timer) {\n      return;\n    }\n\n    this.timer = setInterval(() => {\n      this.flush().catch(() => {\n        // Error already handled in flush()\n      });\n    }, this.config.flushIntervalMs);\n\n    // Don't prevent process exit\n    this.timer.unref();\n  }\n\n  private stopTimer(): void {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n\n  private clamp(value: number, min: number, max: number): number {\n    return Math.min(Math.max(value, min), max);\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Create an event queue with default configuration\n */\nexport function createEventQueue<T>(\n  onFlush: FlushCallback<T>,\n  config?: Partial<Omit<EventQueueConfig<T>, 'onFlush'>>\n): EventQueue<T> {\n  return new EventQueue({\n    maxBatchSize: 10,\n    flushIntervalMs: 5000,\n    maxQueueSize: 1000,\n    ...config,\n    onFlush,\n  });\n}\n"]}