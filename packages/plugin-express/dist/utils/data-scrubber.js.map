{"version":3,"file":"data-scrubber.js","sourceRoot":"","sources":["../../src/utils/data-scrubber.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Data Scrubber Utility\n *\n * Following Sentry's data scrubbing patterns:\n * - Field name-based scrubbing\n * - Pattern-based scrubbing (credit cards, SSNs, tokens)\n * - Recursive object scrubbing\n * - Configurable denylist\n */\n\nimport {\n  DEFAULT_SENSITIVE_FIELDS,\n  SENSITIVE_PATTERNS,\n  type PrivacyConfig,\n} from '@lattice.black/core';\n\nconst REDACTED = '[REDACTED]';\nconst MAX_DEPTH = 10;\n\n/**\n * Create a set of lowercase sensitive field names for efficient lookup\n */\nfunction createSensitiveFieldSet(\n  additionalFields: string[] = []\n): Set<string> {\n  const fields = [...DEFAULT_SENSITIVE_FIELDS, ...additionalFields];\n  return new Set(fields.map((f) => f.toLowerCase()));\n}\n\n/**\n * Check if a field name should be scrubbed\n */\nfunction isSensitiveField(\n  fieldName: string,\n  sensitiveFields: Set<string>\n): boolean {\n  const lowerName = fieldName.toLowerCase();\n\n  // Check for exact match or partial match\n  for (const sensitive of sensitiveFields) {\n    if (lowerName === sensitive || lowerName.includes(sensitive)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Scrub sensitive patterns from a string value\n */\nfunction scrubPatterns(value: string): string {\n  let result = value;\n\n  for (const pattern of SENSITIVE_PATTERNS) {\n    // Create a new RegExp to reset lastIndex\n    const regex = new RegExp(pattern.source, pattern.flags);\n    result = result.replace(regex, REDACTED);\n  }\n\n  return result;\n}\n\n/**\n * Recursively scrub sensitive data from an object\n */\nexport function scrubObject(\n  obj: unknown,\n  sensitiveFields: Set<string>,\n  depth = 0\n): unknown {\n  // Prevent infinite recursion\n  if (depth > MAX_DEPTH) {\n    return obj;\n  }\n\n  // Handle null/undefined\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  // Handle strings - check for sensitive patterns\n  if (typeof obj === 'string') {\n    return scrubPatterns(obj);\n  }\n\n  // Handle primitives\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    return obj.map((item) => scrubObject(item, sensitiveFields, depth + 1));\n  }\n\n  // Handle objects\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (isSensitiveField(key, sensitiveFields)) {\n      result[key] = REDACTED;\n    } else if (typeof value === 'string') {\n      result[key] = scrubPatterns(value);\n    } else if (typeof value === 'object' && value !== null) {\n      result[key] = scrubObject(value, sensitiveFields, depth + 1);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Data scrubber class with configurable options\n */\nexport class DataScrubber {\n  private readonly sensitiveFields: Set<string>;\n\n  constructor(additionalFields: string[] = []) {\n    this.sensitiveFields = createSensitiveFieldSet(additionalFields);\n  }\n\n  /**\n   * Scrub sensitive data from an object\n   */\n  scrub<T extends Record<string, unknown>>(obj: T): T {\n    return scrubObject(obj, this.sensitiveFields) as T;\n  }\n\n  /**\n   * Scrub sensitive patterns from a string\n   */\n  scrubString(value: string): string {\n    return scrubPatterns(value);\n  }\n\n  /**\n   * Check if a field name is sensitive\n   */\n  isSensitive(fieldName: string): boolean {\n    return isSensitiveField(fieldName, this.sensitiveFields);\n  }\n}\n\n/**\n * Create a data scrubber from privacy config\n */\nexport function createDataScrubber(privacy: PrivacyConfig): DataScrubber {\n  return new DataScrubber(privacy.additionalPiiFields);\n}\n\n/**\n * Default data scrubber instance\n */\nexport const defaultScrubber = new DataScrubber();\n\n/**\n * Scrub HTTP headers based on privacy config\n * Only returns headers in the safe list\n */\nexport function scrubHeaders(\n  headers: Record<string, string | string[] | undefined>,\n  privacy: PrivacyConfig\n): Record<string, string | string[] | undefined> {\n  if (!privacy.captureRequestHeaders) {\n    // Only capture safe headers\n    const safeSet = new Set(privacy.safeHeaders.map((h) => h.toLowerCase()));\n    const result: Record<string, string | string[] | undefined> = {};\n\n    for (const [key, value] of Object.entries(headers)) {\n      if (safeSet.has(key.toLowerCase())) {\n        result[key] = value;\n      }\n    }\n\n    return result;\n  }\n\n  // Capture all headers but scrub sensitive ones\n  const scrubber = createDataScrubber(privacy);\n  return scrubber.scrub(headers as Record<string, unknown>) as Record<\n    string,\n    string | string[] | undefined\n  >;\n}\n\n/**\n * Scrub query parameters based on privacy config\n */\nexport function scrubQueryParams(\n  query: Record<string, unknown>,\n  privacy: PrivacyConfig\n): Record<string, unknown> | undefined {\n  if (!privacy.captureQueryParams) {\n    return undefined;\n  }\n\n  const scrubber = createDataScrubber(privacy);\n  return scrubber.scrub(query);\n}\n\n/**\n * Scrub request body based on privacy config\n */\nexport function scrubRequestBody(\n  body: unknown,\n  privacy: PrivacyConfig\n): unknown {\n  if (!privacy.captureRequestBody) {\n    return undefined;\n  }\n\n  if (typeof body !== 'object' || body === null) {\n    return body;\n  }\n\n  const scrubber = createDataScrubber(privacy);\n  return scrubber.scrub(body as Record<string, unknown>);\n}\n"]}