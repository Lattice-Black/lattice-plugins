{"version":3,"file":"metrics-tracker.js","sourceRoot":"","sources":["../../src/middleware/metrics-tracker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Metrics Tracker Middleware for Express\n *\n * Tracks request metrics with:\n * - Configurable sampling to reduce data volume\n * - Event batching for performance\n * - Graceful shutdown support\n *\n * Following patterns from OpenTelemetry and Segment.\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { HTTP_HEADERS, SamplingConfig, BatchConfig } from '@lattice.black/core';\nimport { EventQueue, createEventQueue } from '../utils/event-queue';\nimport { Sampler, createSampler } from '../utils/sampler';\n\n/**\n * Request metrics data\n */\nexport interface RequestMetrics {\n  method: string;\n  path: string;\n  statusCode: number;\n  responseTime: number;\n  timestamp: Date;\n  callerServiceName?: string;\n  serviceName: string;\n}\n\n/**\n * Metrics tracker configuration\n */\nexport interface MetricsTrackerConfig {\n  enabled?: boolean;\n  debug?: boolean;\n  sampling?: Partial<SamplingConfig>;\n  batching?: Partial<BatchConfig>;\n}\n\n/**\n * Metrics Tracker with batching and sampling support\n */\nexport class MetricsTracker {\n  private readonly sampler: Sampler;\n  private readonly eventQueue: EventQueue<RequestMetrics>;\n  private readonly enabled: boolean;\n  private readonly debug: boolean;\n  private isShutdown = false;\n\n  constructor(\n    private serviceName: string,\n    private apiEndpoint: string,\n    private apiKey: string,\n    config: MetricsTrackerConfig = {}\n  ) {\n    this.enabled = config.enabled !== false;\n    this.debug = config.debug ?? false;\n\n    // Create sampler\n    this.sampler = createSampler({\n      errors: 1.0,\n      metrics: config.sampling?.metrics ?? 1.0,\n      rules: config.sampling?.rules ?? [],\n    });\n\n    // Create event queue for batching\n    this.eventQueue = createEventQueue<RequestMetrics>(\n      async (metrics) => this.sendBatch(metrics),\n      {\n        maxBatchSize: config.batching?.maxBatchSize ?? 10,\n        flushIntervalMs: config.batching?.flushIntervalMs ?? 5000,\n        maxQueueSize: config.batching?.maxQueueSize ?? 1000,\n        onError: (error) => this.log('error', `Batch send failed: ${error.message}`),\n        enabled: this.enabled,\n      }\n    );\n  }\n\n  /**\n   * Express middleware for tracking request metrics\n   */\n  middleware() {\n    return (req: Request, res: Response, next: NextFunction) => {\n      if (!this.enabled || this.isShutdown) {\n        return next();\n      }\n\n      // Check sampling before tracking\n      const shouldTrack = this.sampler.shouldSample({\n        eventType: 'metric',\n        path: req.path,\n        method: req.method,\n      });\n\n      if (!shouldTrack) {\n        this.log('debug', `Skipping metric (sampled out): ${req.method} ${req.path}`);\n        return next();\n      }\n\n      const startTime = Date.now();\n      const originalEnd = res.end.bind(res);\n      const self = this;\n\n      // Override res.end to capture metrics after response\n      res.end = function (this: Response, ...args: unknown[]): Response {\n        const responseTime = Date.now() - startTime;\n\n        // Extract caller service from distributed tracing header\n        const headerValue = req.get(HTTP_HEADERS.ORIGIN_SERVICE) || req.get('X-Origin-Service');\n        const callerServiceName = Array.isArray(headerValue) ? headerValue[0] : headerValue;\n\n        const metric: RequestMetrics = {\n          method: req.method,\n          path: req.path,\n          statusCode: res.statusCode,\n          responseTime,\n          timestamp: new Date(),\n          callerServiceName,\n          serviceName: self.serviceName,\n        };\n\n        // Enqueue metric asynchronously\n        self.enqueueMetric(metric);\n\n        // Call original end\n        return (originalEnd as (...args: unknown[]) => Response)(...args);\n      } as Response['end'];\n\n      next();\n    };\n  }\n\n  /**\n   * Force flush all pending metrics\n   */\n  async forceFlush(): Promise<void> {\n    await this.eventQueue.forceFlush();\n  }\n\n  /**\n   * Shutdown metrics tracker\n   */\n  shutdown(): void {\n    this.isShutdown = true;\n    this.eventQueue.shutdown();\n  }\n\n  /**\n   * Get queue state for monitoring\n   */\n  getState() {\n    return this.eventQueue.getState();\n  }\n\n  /**\n   * Get aggregated statistics\n   */\n  getStats() {\n    const state = this.eventQueue.getState();\n    return {\n      queueSize: state.size,\n      droppedCount: state.dropped,\n      flushCount: state.flushCount,\n      failedFlushCount: state.failedFlushCount,\n    };\n  }\n\n  // Private methods\n\n  /**\n   * Enqueue a metric for batched submission\n   */\n  private enqueueMetric(metric: RequestMetrics): void {\n    const queued = this.eventQueue.enqueue(metric);\n    if (queued) {\n      this.log('debug', `Queued metric: ${metric.method} ${metric.path} - ${metric.statusCode} (${metric.responseTime}ms)`);\n    } else {\n      this.log('warn', 'Metric dropped: queue full');\n    }\n  }\n\n  /**\n   * Send batch of metrics to API\n   */\n  private async sendBatch(metrics: RequestMetrics[]): Promise<void> {\n    if (metrics.length === 0) {\n      return;\n    }\n\n    try {\n      // Transform metrics to performance traces format\n      const traces = metrics.map((metric) => ({\n        service_id: metric.serviceName,\n        operation_name: `${metric.method} ${metric.path}`,\n        operation_type: 'http_request',\n        start_time: new Date(metric.timestamp.getTime() - metric.responseTime),\n        duration_ms: metric.responseTime,\n        status_code: metric.statusCode,\n        method: metric.method,\n        path: metric.path,\n        caller_service: metric.callerServiceName,\n      }));\n\n      const response = await fetch(`${this.apiEndpoint}/performance/traces/batch`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(this.apiKey && { [HTTP_HEADERS.API_KEY]: this.apiKey }),\n        },\n        body: JSON.stringify({ traces }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n\n      this.log('debug', `Sent ${metrics.length} metrics to API`);\n    } catch (error) {\n      this.log('error', `Failed to send metrics: ${(error as Error).message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Conditional logging based on debug mode\n   */\n  private log(level: 'debug' | 'warn' | 'error', message: string): void {\n    const prefix = '[Lattice MetricsTracker]';\n\n    if (level === 'error') {\n      console.error(`${prefix} ${message}`);\n    } else if (level === 'warn') {\n      console.warn(`${prefix} ${message}`);\n    } else if (this.debug) {\n      console.log(`${prefix} ${message}`);\n    }\n  }\n}\n"]}