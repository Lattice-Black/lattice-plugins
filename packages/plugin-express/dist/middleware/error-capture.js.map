{"version":3,"file":"error-capture.js","sourceRoot":"","sources":["../../src/middleware/error-capture.ts"],"names":[],"mappings":";;;AAoWA,gDAaC;AApWD,iEAA8C;AAC9C,8CAK6B;AAE7B,sDAAoE;AACpE,8CAA0D;AAC1D,0DAKgC;AAChC,wDAAkD;AA6ClD,MAAa,YAAY;IACN,MAAM,CAA6B;IACnC,OAAO,CAAU;IACjB,UAAU,CAAkC;IAC5C,UAAU,CAAuC;IAC1D,UAAU,GAAG,KAAK,CAAC;IAE3B,YAAY,MAA0B;QAEpC,IAAI,CAAC,MAAM,GAAG;YACZ,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,WAAW,EAAE,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;YAClD,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,WAAW,EAAE,CAAC,MAAM,CAAC,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,aAAa,CAG5D;YAChB,OAAO,EAAE,MAAM,CAAC,OAAO,KAAK,KAAK;YACjC,KAAK,EAAE,MAAM,CAAC,KAAK,IAAI,KAAK;YAC5B,OAAO,EAAE;gBACP,GAAG,6BAAsB;gBACzB,GAAG,MAAM,CAAC,OAAO;aAClB;SACF,CAAC;QAEF,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;QAGpC,IAAI,CAAC,OAAO,GAAG,IAAA,uBAAa,EAAC;YAC3B,MAAM,EAAE,MAAM,CAAC,QAAQ,EAAE,MAAM,IAAI,GAAG;YACtC,OAAO,EAAE,GAAG;YACZ,KAAK,EAAE,MAAM,CAAC,QAAQ,EAAE,KAAK,IAAI,EAAE;SACpC,CAAC,CAAC;QAGH,IAAI,CAAC,UAAU,GAAG,IAAA,8BAAgB,EAChC,KAAK,EAAE,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EACxC;YACE,YAAY,EAAE,MAAM,CAAC,QAAQ,EAAE,YAAY,IAAI,EAAE;YACjD,eAAe,EAAE,MAAM,CAAC,QAAQ,EAAE,eAAe,IAAI,IAAI;YACzD,YAAY,EAAE,MAAM,CAAC,QAAQ,EAAE,YAAY,IAAI,IAAI;YACnD,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,sBAAsB,KAAK,CAAC,OAAO,EAAE,CAAC;YAC5E,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO;SAC7B,CACF,CAAC;IACJ,CAAC;IAMD,UAAU;QACR,OAAO,KAAK,EAAE,GAAU,EAAE,GAAY,EAAE,IAAc,EAAE,IAAkB,EAAE,EAAE;YAC5E,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC5C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;YACnB,CAAC;YAGD,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;gBAC9C,SAAS,EAAE,OAAO;gBAClB,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,MAAM,EAAE,GAAG,CAAC,MAAM;gBAClB,SAAS,EAAE,GAAG,CAAC,IAAI;aACpB,CAAC,CAAC;YAEH,IAAI,CAAC,aAAa,EAAE,CAAC;gBACnB,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,iCAAiC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC/D,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;YACnB,CAAC;YAGD,IAAA,wBAAS,EACP,GAAG,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,EAC3D,SAAS,EACT,yBAAyB,CAC1B,CAAC,KAAK,CAAC,GAAG,EAAE;YAEb,CAAC,CAAC,CAAC;YAGH,IAAI,CAAC,GAAG,CAAC,CAAC;QACZ,CAAC,CAAC;IACJ,CAAC;IAKD,KAAK,CAAC,YAAY,CAAC,KAAY,EAAE,OAAiC;QAChE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YAC5C,OAAO;QACT,CAAC;QAED,IAAI,CAAC;YACH,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,IAAA,kCAAkB,EAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAwB;gBACpC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW;gBACnC,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW;gBACpC,UAAU,EAAE,KAAK,CAAC,IAAI,IAAI,OAAO;gBACjC,OAAO,EAAE,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,OAAO,IAAI,eAAe,CAAC;gBAC/D,WAAW,EAAE,WAAW;gBACxB,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAkC,CAAC,CAAC,CAAC,CAAC,SAAS;gBACjF,SAAS,EAAE,IAAI,IAAI,EAAE;aACtB,CAAC;YAGF,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBACpB,MAAM,MAAM,GAAG,MAAM,IAAA,wBAAS,EAC5B,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAW,CAAC,UAAU,CAAC,CAAC,EACnD,UAAU,EACV,yBAAyB,CAC1B,CAAC;gBAEF,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;oBACpB,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,qCAAqC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;oBACrE,OAAO;gBACT,CAAC;gBAED,UAAU,GAAG,MAAM,CAAC;YACtB,CAAC;YAGD,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACnD,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,2BAA2B,CAAC,CAAC;YAChD,CAAC;QACH,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,0BAA2B,GAAa,CAAC,OAAO,EAAE,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;IAKD,KAAK,CAAC,UAAU;QACd,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC;IACrC,CAAC;IAKD,QAAQ;QACN,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;IAC7B,CAAC;IAKD,QAAQ;QACN,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;IACpC,CAAC;IAOO,mBAAmB,CAAC,GAAY;QACtC,MAAM,OAAO,GAA4B;YACvC,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,IAAI,EAAE,GAAG,CAAC,IAAI;YACd,GAAG,EAAE,GAAG,CAAC,GAAG;SACb,CAAC;QAGF,MAAM,SAAS,GAAG,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACxC,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,CAAC,YAAY,CAAC,GAAG,SAAS,CAAC;QACpC,CAAC;QAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,qBAAqB,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC5F,MAAM,OAAO,GAAG,IAAA,4BAAY,EAC1B,GAAG,CAAC,OAAwD,EAC5D,IAAI,CAAC,MAAM,CAAC,OAAO,CACpB,CAAC;YACF,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACpC,OAAO,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC;YAC/B,CAAC;QACH,CAAC;QAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,kBAAkB,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;YACxD,MAAM,KAAK,GAAG,IAAA,gCAAgB,EAC5B,GAAG,CAAC,KAAgC,EACpC,IAAI,CAAC,MAAM,CAAC,OAAO,CACpB,CAAC;YACF,IAAI,KAAK,EAAE,CAAC;gBACV,OAAO,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;YAC3B,CAAC;QACH,CAAC;QAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,kBAAkB,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC;YACvD,MAAM,IAAI,GAAG,IAAA,gCAAgB,EAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAC7D,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACvB,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YACzB,CAAC;QACH,CAAC;QAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC;YACnD,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;QACzB,CAAC;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAKO,eAAe,CAAC,KAAY;QAClC,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,IAAA,6BAAK,EAAC,KAAK,CAAC,CAAC;YAE5B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;gBAC5B,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,SAAS;gBACrC,WAAW,EAAE,KAAK,CAAC,UAAU,IAAI,CAAC;gBAClC,aAAa,EAAE,KAAK,CAAC,YAAY;gBACjC,aAAa,EAAE,KAAK,CAAC,YAAY,IAAI,aAAa;aACnD,CAAC,CAAC,CAAC;QACN,CAAC;QAAC,MAAM,CAAC;YACP,OAAO;gBACL;oBACE,QAAQ,EAAE,SAAS;oBACnB,WAAW,EAAE,CAAC;oBACd,aAAa,EAAE,KAAK,CAAC,IAAI,IAAI,OAAO;iBACrC;aACF,CAAC;QACJ,CAAC;IACH,CAAC;IAKO,KAAK,CAAC,SAAS,CAAC,MAA6B;QACnD,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO;QACT,CAAC;QAED,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,eAAe,EAAE;gBACtE,MAAM,EAAE,MAAM;gBACd,OAAO,EAAE;oBACP,cAAc,EAAE,kBAAkB;oBAClC,CAAC,mBAAY,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM;iBAC3C;gBACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC;aACjC,CAAC,CAAC;YAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;gBACjB,MAAM,IAAI,KAAK,CAAC,cAAc,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;YAC1E,CAAC;YAED,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,MAAM,CAAC,MAAM,gBAAgB,CAAC,CAAC;QAC3D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,0BAA2B,KAAe,CAAC,OAAO,EAAE,CAAC,CAAC;YACxE,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAKO,GAAG,CAAC,KAAiC,EAAE,OAAe;QAC5D,MAAM,MAAM,GAAG,wBAAwB,CAAC;QAExC,IAAI,KAAK,KAAK,OAAO,EAAE,CAAC;YACtB,OAAO,CAAC,KAAK,CAAC,GAAG,MAAM,IAAI,OAAO,EAAE,CAAC,CAAC;QACxC,CAAC;aAAM,IAAI,KAAK,KAAK,MAAM,EAAE,CAAC;YAC5B,OAAO,CAAC,IAAI,CAAC,GAAG,MAAM,IAAI,OAAO,EAAE,CAAC,CAAC;QACvC,CAAC;aAAM,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YAC7B,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,IAAI,OAAO,EAAE,CAAC,CAAC;QACtC,CAAC;IACH,CAAC;CACF;AArRD,oCAqRC;AAKD,SAAgB,kBAAkB,CAAC,MAA6B;IAC9D,OAAO,IAAI,YAAY,CAAC;QACtB,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,KAAK,EAAE,MAAM,CAAC,KAAK;QACnB,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,QAAQ,EAAE,MAAM,CAAC,QAAQ;QACzB,QAAQ,EAAE,MAAM,CAAC,QAAQ;QACzB,UAAU,EAAE,MAAM,CAAC,eAAe;KACnC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * Error Capture Middleware for Express\n *\n * Captures unhandled errors and sends them to Lattice API with:\n * - Privacy-first data capture (no PII by default)\n * - Configurable sampling to reduce data volume\n * - Event batching for performance\n * - beforeSend hook for filtering/modifying events\n *\n * Following Sentry and OpenTelemetry patterns.\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { parse } from 'error-stack-parser-es';\nimport {\n  HTTP_HEADERS,\n  PrivacyConfig,\n  DEFAULT_PRIVACY_CONFIG,\n  BeforeSendHook,\n} from '@lattice.black/core';\nimport type { StackFrame, ErrorEvent } from '@lattice.black/core';\nimport { EventQueue, createEventQueue } from '../utils/event-queue';\nimport { Sampler, createSampler } from '../utils/sampler';\nimport {\n  scrubHeaders,\n  scrubQueryParams,\n  scrubRequestBody,\n  createDataScrubber,\n} from '../utils/data-scrubber';\nimport { safeAsync } from '../utils/safe-wrapper';\nimport type { ResolvedLatticeConfig } from '../config/types';\n\n/**\n * Error capture configuration\n */\nexport interface ErrorCaptureConfig {\n  serviceName: string;\n  apiEndpoint: string;\n  apiKey: string;\n  environment?: string;\n  enabled?: boolean;\n  debug?: boolean;\n  privacy?: Partial<PrivacyConfig>;\n  sampling?: {\n    errors?: number;\n    rules?: Array<{\n      match: { path?: string; method?: string; errorType?: string };\n      rate: number;\n    }>;\n  };\n  batching?: {\n    maxBatchSize?: number;\n    flushIntervalMs?: number;\n    maxQueueSize?: number;\n  };\n  beforeSend?: BeforeSendHook<Partial<ErrorEvent>>;\n}\n\n/**\n * Resolved error capture configuration with defaults\n */\ninterface ResolvedErrorCaptureConfig {\n  serviceName: string;\n  apiEndpoint: string;\n  apiKey: string;\n  environment: 'development' | 'staging' | 'production';\n  enabled: boolean;\n  debug: boolean;\n  privacy: PrivacyConfig;\n}\n\n/**\n * Error Capture class with batching, sampling, and privacy controls\n */\nexport class ErrorCapture {\n  private readonly config: ResolvedErrorCaptureConfig;\n  private readonly sampler: Sampler;\n  private readonly eventQueue: EventQueue<Partial<ErrorEvent>>;\n  private readonly beforeSend?: BeforeSendHook<Partial<ErrorEvent>>;\n  private isShutdown = false;\n\n  constructor(config: ErrorCaptureConfig) {\n    // Resolve configuration with defaults\n    this.config = {\n      serviceName: config.serviceName,\n      apiEndpoint: config.apiEndpoint.replace(/\\/$/, ''),\n      apiKey: config.apiKey,\n      environment: (config.environment || process.env['NODE_ENV'] || 'development') as\n        | 'development'\n        | 'staging'\n        | 'production',\n      enabled: config.enabled !== false,\n      debug: config.debug ?? false,\n      privacy: {\n        ...DEFAULT_PRIVACY_CONFIG,\n        ...config.privacy,\n      },\n    };\n\n    this.beforeSend = config.beforeSend;\n\n    // Create sampler\n    this.sampler = createSampler({\n      errors: config.sampling?.errors ?? 1.0,\n      metrics: 1.0,\n      rules: config.sampling?.rules ?? [],\n    });\n\n    // Create event queue for batching\n    this.eventQueue = createEventQueue<Partial<ErrorEvent>>(\n      async (events) => this.sendBatch(events),\n      {\n        maxBatchSize: config.batching?.maxBatchSize ?? 10,\n        flushIntervalMs: config.batching?.flushIntervalMs ?? 5000,\n        maxQueueSize: config.batching?.maxQueueSize ?? 1000,\n        onError: (error) => this.log('error', `Batch send failed: ${error.message}`),\n        enabled: this.config.enabled,\n      }\n    );\n  }\n\n  /**\n   * Express error handling middleware\n   * MUST be registered AFTER all routes\n   */\n  middleware() {\n    return async (err: Error, req: Request, _res: Response, next: NextFunction) => {\n      if (!this.config.enabled || this.isShutdown) {\n        return next(err);\n      }\n\n      // Check sampling\n      const shouldCapture = this.sampler.shouldSample({\n        eventType: 'error',\n        path: req.path,\n        method: req.method,\n        errorType: err.name,\n      });\n\n      if (!shouldCapture) {\n        this.log('debug', `Dropping error (sampled out): ${err.name}`);\n        return next(err);\n      }\n\n      // Capture error asynchronously - never block the response\n      safeAsync(\n        () => this.captureError(err, this.buildRequestContext(req)),\n        undefined,\n        'ErrorCapture.middleware'\n      ).catch(() => {\n        // Error already logged by safeAsync\n      });\n\n      // Always pass the error to the next handler\n      next(err);\n    };\n  }\n\n  /**\n   * Manually capture an error\n   */\n  async captureError(error: Error, context?: Record<string, unknown>): Promise<void> {\n    if (!this.config.enabled || this.isShutdown) {\n      return;\n    }\n\n    try {\n      const stackFrames = this.parseStackTrace(error);\n      const scrubber = createDataScrubber(this.config.privacy);\n\n      let errorEvent: Partial<ErrorEvent> = {\n        service_id: this.config.serviceName,\n        environment: this.config.environment,\n        error_type: error.name || 'Error',\n        message: scrubber.scrubString(error.message || 'Unknown error'),\n        stack_trace: stackFrames,\n        context: context ? scrubber.scrub(context as Record<string, unknown>) : undefined,\n        timestamp: new Date(),\n      };\n\n      // Call beforeSend hook if provided\n      if (this.beforeSend) {\n        const result = await safeAsync(\n          () => Promise.resolve(this.beforeSend!(errorEvent)),\n          errorEvent,\n          'ErrorCapture.beforeSend'\n        );\n\n        if (result === null) {\n          this.log('debug', `Error dropped by beforeSend hook: ${error.name}`);\n          return;\n        }\n\n        errorEvent = result;\n      }\n\n      // Enqueue for batched submission\n      const queued = this.eventQueue.enqueue(errorEvent);\n      if (!queued) {\n        this.log('warn', 'Error dropped: queue full');\n      }\n    } catch (err) {\n      this.log('error', `Error in captureError: ${(err as Error).message}`);\n    }\n  }\n\n  /**\n   * Force flush all pending errors\n   */\n  async forceFlush(): Promise<void> {\n    await this.eventQueue.forceFlush();\n  }\n\n  /**\n   * Shutdown error capture\n   */\n  shutdown(): void {\n    this.isShutdown = true;\n    this.eventQueue.shutdown();\n  }\n\n  /**\n   * Get queue state for monitoring\n   */\n  getState() {\n    return this.eventQueue.getState();\n  }\n\n  // Private methods\n\n  /**\n   * Build request context respecting privacy settings\n   */\n  private buildRequestContext(req: Request): Record<string, unknown> {\n    const context: Record<string, unknown> = {\n      method: req.method,\n      path: req.path,\n      url: req.url,\n    };\n\n    // Only add user agent (always considered safe)\n    const userAgent = req.get('user-agent');\n    if (userAgent) {\n      context['user_agent'] = userAgent;\n    }\n\n    // Conditionally add headers based on privacy config\n    if (this.config.privacy.captureRequestHeaders || this.config.privacy.safeHeaders.length > 0) {\n      const headers = scrubHeaders(\n        req.headers as Record<string, string | string[] | undefined>,\n        this.config.privacy\n      );\n      if (Object.keys(headers).length > 0) {\n        context['headers'] = headers;\n      }\n    }\n\n    // Conditionally add query params\n    if (this.config.privacy.captureQueryParams && req.query) {\n      const query = scrubQueryParams(\n        req.query as Record<string, unknown>,\n        this.config.privacy\n      );\n      if (query) {\n        context['query'] = query;\n      }\n    }\n\n    // Conditionally add request body\n    if (this.config.privacy.captureRequestBody && req.body) {\n      const body = scrubRequestBody(req.body, this.config.privacy);\n      if (body !== undefined) {\n        context['body'] = body;\n      }\n    }\n\n    // Conditionally add IP address\n    if (this.config.privacy.captureIpAddress && req.ip) {\n      context['ip'] = req.ip;\n    }\n\n    return context;\n  }\n\n  /**\n   * Parse error stack trace\n   */\n  private parseStackTrace(error: Error): StackFrame[] {\n    try {\n      const frames = parse(error);\n\n      return frames.map((frame) => ({\n        filename: frame.fileName || 'unknown',\n        line_number: frame.lineNumber || 0,\n        column_number: frame.columnNumber,\n        function_name: frame.functionName || '<anonymous>',\n      }));\n    } catch {\n      return [\n        {\n          filename: 'unknown',\n          line_number: 0,\n          function_name: error.name || 'Error',\n        },\n      ];\n    }\n  }\n\n  /**\n   * Send batch of errors to API\n   */\n  private async sendBatch(errors: Partial<ErrorEvent>[]): Promise<void> {\n    if (errors.length === 0) {\n      return;\n    }\n\n    try {\n      const response = await fetch(`${this.config.apiEndpoint}/errors/batch`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          [HTTP_HEADERS.API_KEY]: this.config.apiKey,\n        },\n        body: JSON.stringify({ errors }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n\n      this.log('debug', `Sent ${errors.length} errors to API`);\n    } catch (error) {\n      this.log('error', `Failed to send errors: ${(error as Error).message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Conditional logging based on debug mode\n   */\n  private log(level: 'debug' | 'warn' | 'error', message: string): void {\n    const prefix = '[Lattice ErrorCapture]';\n\n    if (level === 'error') {\n      console.error(`${prefix} ${message}`);\n    } else if (level === 'warn') {\n      console.warn(`${prefix} ${message}`);\n    } else if (this.config.debug) {\n      console.log(`${prefix} ${message}`);\n    }\n  }\n}\n\n/**\n * Create error capture from full Lattice config\n */\nexport function createErrorCapture(config: ResolvedLatticeConfig): ErrorCapture {\n  return new ErrorCapture({\n    serviceName: config.serviceName,\n    apiEndpoint: config.apiEndpoint,\n    apiKey: config.apiKey,\n    environment: config.environment,\n    enabled: config.enabled,\n    debug: config.debug,\n    privacy: config.privacy,\n    sampling: config.sampling,\n    batching: config.batching,\n    beforeSend: config.beforeSendError,\n  });\n}\n"]}